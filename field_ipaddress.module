<?php

/**
 * Implements hook_migrate_api().
 */
function field_ipaddress_migrate_api() {
  $api = array(
    'api' => 2,
  );
  return $api;
}

/**
 * Implements hook_field_info().
 */
function field_ipaddress_field_info() {
  return array(
    'field_ipaddress' => array(
      'label' => t('IP Address'),
      'description' => t('Stores a single IP address, or range of IP addresses.'),
      'default_widget' => 'field_ipaddress_cidr',
      'default_formatter' => 'field_ipaddress_cidr',
    ),
  );
}

/**
 * Implements hook_presave().
 *
 * TODO this needs to be reviewed, it seems pretty ugly. We are taking the fieldset values and making it flat.
 */
function field_ipaddress_field_presave($entity_type, $entity, $field, $instance, $langcode, &$items) {
  if ($field['type'] == 'field_ipaddress') {
    foreach ($items as $delta => $item) {
      if (!empty($item['ipaddress']['start']) && !empty($item['ipaddress']['end'])) {
        $items[$delta]['start'] = $item['ipaddress']['start'];
        $items[$delta]['end'] = $item['ipaddress']['end'];        
      } else {
        unset($items[$delta]);
      }
    }
  }
}

/**
 * Implements hook_field_is_empty().
 */
function field_ipaddress_field_is_empty($item, $field) {
  return empty($item['ipaddress']['start']) || empty($item['ipaddress']['end']);
}

/**
 * Implements hook_field_formatter_info().
 */
function field_ipaddress_field_formatter_info() {
  return array(
    'field_ipaddress_shorthand' => array(
      'label' => t('List of IPs (shorthand)'),
      'field types' => array('field_ipaddress'),
    ),
    'field_ipaddress_cidr' => array(
      'label' => t('List of IPs (CIDR)'),
      'field types' => array('field_ipaddress'),
    ),
  );
}

/**
 * Implements hook_field_formatter_view().
 */
function field_ipaddress_field_formatter_view($entity_type, $entity, $field, $instance, $langcode, $items, $display) {
  $element = array();
  switch ($display['type']) {
    case 'field_ipaddress_shorthand':
      $networks = array();
      foreach ($items as $delta => $item) {
        if (!empty($item)) {
          $networks[] = _field_ipaddress_long2shorthand($item['start'], $item['end']);
        }
      }
      if (!empty($networks)) {
        if (count($networks) === 1) {
          $element[0] = array(
            '#markup' => $networks[0],
          );
        }
        else {
          $element[0] = array(
            '#theme' => 'item_list',
            '#items' => $networks,
          );
        }
      }
      break;

    case 'field_ipaddress_cidr':
      $networks = array();
      foreach ($items as $delta => $item) {
        if (!empty($item)) {
          $networks[] = _field_ipaddress_long2cidr($item['start'], $item['end']);
        }
      }
      if (!empty($networks)) {
        if (count($networks) === 1) {
          $element[0] = array(
            '#markup' => $networks[0],
          );
        }
        else {
          $element[0] = array(
            '#theme' => 'item_list',
            '#items' => $networks,
          );
        }
      }
      break;
  }

  return $element;
}

/**
 * Implements hook_field_widget_info().
 */
function field_ipaddress_field_widget_info() {
  return array(
    'field_ipaddress_shorthand' => array(
      'label' => t('Shorthand input'),
      'field types' => array('field_ipaddress'),
    ),
    'field_ipaddress_cidr' => array(
      'label' => t('CIDR input'),
      'field types' => array('field_ipaddress'),
    ),
    'field_ipaddress_long' => array(
      'label' => t('Long input'),
      'field types' => array('field_ipaddress'),
    ),
  );
}

/**
 * Implements hook_field_widget_form().
 */
function field_ipaddress_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  $widget = $element;
  $widget['#delta'] = $delta;

  switch ($instance['widget']['type']) {
    case 'field_ipaddress_long':
      $widget += array(
        '#type' => 'fieldset',
        '#delta' => $delta,
      );
      $widget['start'] = array(
        '#type' => 'textfield',
        '#title' => t('Start'),
        '#size' => 15,
        '#default_value' => isset($items[$delta]['start']) ? $items[$delta]['start'] : '',
      );
      $widget['end'] = array(
        '#type' => 'textfield',
        '#title' => t('End'),
        '#size' => 15,
        '#default_value' => isset($items[$delta]['end']) ? $items[$delta]['end'] : '',
      );
      break;

    case 'field_ipaddress_shorthand':
      $value = (isset($items[$delta]['start']) && isset($items[$delta]['end'])) ?
        _field_ipaddress_long2shorthand($items[$delta]['start'], $items[$delta]['end']) :
        '';
      $widget += array(
        '#type' => 'textfield',
        '#default_value' => $value,
        '#size' => 30,
        '#maxlength' => 100,
        '#element_validate' => array('_field_ipaddress_validate_shorthand'),
      );
      break;
      
    case 'field_ipaddress_cidr':
      $value = (isset($items[$delta]['start']) && isset($items[$delta]['end'])) ?
        _field_ipaddress_long2cidr($items[$delta]['start'], $items[$delta]['end']) :
        '';
      $widget += array(
        '#type' => 'textfield',
        '#default_value' => $value,
        '#size' => 30,
        '#maxlength' => 100,
        '#element_validate' => array('_field_ipaddress_validate_cidr'),
      );
      break;
  }
  $element['ipaddress'] = $widget;
  return $element;
}

/**
 * Implements hook_field_widget_error().
 */
function field_ipaddress_field_widget_error($element, $error, $form, &$form_state) {
  switch ($error['error']) {
    case 'field_ipaddress_invalid':
      form_error($element, $error['message']);
      break;
  }
}

/**
 * Validate a CIDR input.
 */
function _field_ipaddress_validate_cidr($element, &$form_state) {
  $delta = $element['#delta'];
  $lang_code = $element['#language'];
  $field = $form_state['field'][$element['#field_name']][$lang_code]['field'];
  $field_name = $field['field_name'];

  $ipaddress = trim($form_state['values'][$field_name][$lang_code][$delta]['ipaddress']);
  if (!empty($ipaddress)) {
    $range = _field_ipaddress_cidr2long($ipaddress);
    if ($range) {
      form_set_value($element, $range, $form_state);
   } else {
      form_error($element, t('Invalid IP range or address.'));
    }
  }
}

/**
 * Validate a shorthand input.
 */
function _field_ipaddress_validate_shorthand($element, &$form_state) {
  $delta = $element['#delta'];
  $lang_code = $element['#language'];
  $field = $form_state['field'][$element['#field_name']][$lang_code]['field'];
  $field_name = $field['field_name'];
  $ipaddress = trim($form_state['values'][$field_name][$lang_code][$delta]['ipaddress']);
  if (!empty($ipaddress)) {
    $value = _field_ipaddress_shorthand2long($ipaddress);
    if ($value) {
      form_set_value($element, $value, $form_state);
   } else {
      form_error($element, t('Invalid IP range or address.'));
    }
  }
}

/**
 * Convert a start address and end address (as longs) into a smaller
 * human readable string.
 *
 * @param int $start The start address as a long
 * @param int $end The end address as a long
 * @return string A start and end range as the small formatted string
 * @example
 *   $s=1869573999, $e=1869574110 => 111.111.111.111-222
 */
function _field_ipaddress_long2shorthand($start, $end) {
  if ($start === $end) {
    $output = long2ip($start);
  } else {
    $s = explode('.', long2ip($start));
    $e = explode('.', long2ip($end));
    if ($s[0] === $e[0] && $s[1] === $e[1] && $s[2] === $e[2]) {
      if ($s[3] === '0' && $e[3] === '255') {
        $s[3] = '*';
        $output = implode('.', $s);
      } else {
        $s[3] = sprintf('%s-%s', $s[3], $e[3]);
        $output = implode('.', $s);
      }
    } else {
      $output = long2ip($start) .' - '. long2ip($end);
    }
  }

  return $output;
}


/**
 * Convert a start address and end address (as longs) into a CIDR.
 */
function _field_ipaddress_long2cidr($start, $end) {
  $mask = (int) $start | ~ (int) $end;
  $cidr = 32 - log(abs($mask), 2);

  $valid = (int) $cidr == $cidr;
  if (!$valid) {  
    return _field_ipaddress_long2shorthand($start, $end);
  }
  return long2ip($start) . '/' . $cidr;

  // TODO: This algorithm may be better:
  //
  // xor-ing will give you the inverse mask, log base 2 of that +1 will
  // return the number of bits that are off in the mask and subtracting
  // from 32 gets you the CIDR notation.
  $long = ip2long($mask);
  $base = ip2long('255.255.255.255');
  $cidr = 32-log(($long ^ $base)+1,2);
}


/**
 * Validate a CIDR
 */
function _field_ipaddress_cidr2long($cidr) {
  list($ip, $cidr) = explode('/', $cidr);

  // TODO
  $start = ip2long($ip);
  $end = ip2long($ip);

  return array(
    'start' => $start,
    'end'   => $end,
  );
}

/**
 *
 */
function _field_ipaddress_shorthand2long($shorthand) {
  $res = _field_ipaddress_shorthand2dottedquad($shorthand);
  if (!$res) {
    return FALSE;
  }
  list($start, $end) = $res;
  return array(
    'start' => ip2long($start),
    'end'   => ip2long($end),
  );
}

/**
 * Take shorthand input and return the dotted quad start and end range.
 *
 * @param input $string An IP range.
 * @return array Start and end addresses in dotted quad format, else FALSE.
 * @example
 *   "111.111.111.*" => array("111.111.111.0", "111.111.111.255")
 *   "111.111.111.111-222" => array("111.111.111.111", "111.111.111.222")
 */
function _field_ipaddress_shorthand2dottedquad($network) {
  $star = strpos($network, '*');
  $dash = strpos($network, '-');

  if (ctype_alpha($network[strlen($network)-1])) {
    // Hostname conversion
    $start = $end = gethostbyname($network);
    if ($start === $network) {
      return FALSE;
    }
  }
  else {
    // Simple validation
    if ($star === false && $dash === false) {
      $res   = long2ip(ip2long($network));
      $start = $end = $res;
      if ($res === '0.0.0.0') {
        return FALSE;
      }
    }

    // Using a star
    if ($star !== false) {
      $start = long2ip(ip2long(str_replace('*', '0', $network)));
      $end   = long2ip(ip2long(str_replace('*', '255', $network)));
      if ($start === '0.0.0.0' || $end === '0.0.0.0') {
        return FALSE;
      }
    }

    // Using a dash
    if ($dash !== FALSE) {
      list($start, $end) = explode('-', $network);

      // Check whether $end is a full IP or just the last quad
      if (strpos($end, '.') !== FALSE) {
        $end = long2ip(ip2long(trim($end)));
      } else {
        // Get the first 3 quads of the start address
        $classc = substr($start, 0, strrpos($start, '.'));
        $classc .= '.' . $end;
        $end = long2ip(ip2long(trim($classc)));
      }

      // Check for failure
      $start = long2ip(ip2long(trim($start)));
      if ($start === '0.0.0.0' || $end === '0.0.0.0') {
        return FALSE;
      }
    }
  }

  return array($start, $end);
}
